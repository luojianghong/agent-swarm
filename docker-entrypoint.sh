#!/bin/bash
set -e

# Validate required environment variables
if [ -z "$CLAUDE_CODE_OAUTH_TOKEN" ]; then
    echo "Error: CLAUDE_CODE_OAUTH_TOKEN environment variable is required"
    exit 1
fi

if [ -z "$API_KEY" ]; then
    echo "Error: API_KEY environment variable is required"
    exit 1
fi

# Role defaults to worker, can be set to "lead"
ROLE="${AGENT_ROLE:-worker}"
MCP_URL="${MCP_BASE_URL:-http://host.docker.internal:3013}"

# Get version from compiled binary (extract just the version number)
VERSION=$(/usr/local/bin/agent-swarm version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' || echo "unknown")

# Determine YOLO mode based on role
if [ "$ROLE" = "lead" ]; then
    YOLO_MODE="${LEAD_YOLO:-false}"
else
    YOLO_MODE="${WORKER_YOLO:-false}"
fi

echo "=== Agent Swarm ${ROLE^} v${VERSION} ==="
echo "Agent ID: ${AGENT_ID:-<not set>}"
echo "MCP Base URL: $MCP_URL"
echo "YOLO Mode: $YOLO_MODE"
echo "Session ID: ${SESSION_ID:-<auto-generated>}"
echo "Working Directory: /workspace"
echo "=========================="

# Initialize PM2 daemon for background service management
echo ""
echo "=== PM2 Initialization ==="
echo "PM2 Home: ${PM2_HOME:-~/.pm2}"
# Ensure PM2 home directory exists (for persistence in /workspace)
mkdir -p "${PM2_HOME:-$HOME/.pm2}"
pm2 startup > /dev/null 2>&1 || true

# Restore services from ecosystem (database-driven, more reliable than pm2 resurrect)
ECOSYSTEM_FILE="/workspace/ecosystem.config.js"
if [ -n "$AGENT_ID" ]; then
    echo "Fetching ecosystem config from MCP server..."
    if curl -s -f -H "Authorization: Bearer ${API_KEY}" \
       -H "X-Agent-ID: ${AGENT_ID}" \
       "${MCP_URL}/ecosystem" > /tmp/ecosystem.json 2>/dev/null; then

        # Check if there are any apps to start
        APP_COUNT=$(cat /tmp/ecosystem.json | jq -r '.apps | length' 2>/dev/null || echo "0")

        if [ "$APP_COUNT" -gt "0" ]; then
            echo "Found $APP_COUNT registered service(s)"
            # Convert JSON to JS module
            echo "module.exports = $(cat /tmp/ecosystem.json);" > "$ECOSYSTEM_FILE"
            echo "Starting services from ecosystem file..."
            pm2 start "$ECOSYSTEM_FILE" || true
            pm2 list
        else
            echo "No services registered for this agent"
        fi
        rm -f /tmp/ecosystem.json
    else
        echo "Could not fetch ecosystem config (MCP server may be unavailable)"
    fi
else
    echo "AGENT_ID not set, skipping ecosystem restore"
fi

# Fallback: try pm2 resurrect for any locally saved processes
if pm2 resurrect 2>/dev/null; then
    pm2 list 2>/dev/null || true
fi
echo "=========================="

# Cleanup function for graceful shutdown
cleanup() {
    echo ""
    echo "Shutting down PM2 processes..."
    pm2 kill 2>/dev/null || true
}
trap cleanup EXIT SIGINT SIGTERM

# ---- Fetch swarm config from API ----
if [ -n "$AGENT_ID" ]; then
    echo "Fetching swarm config from API..."
    if curl -s -f -H "Authorization: Bearer ${API_KEY}" \
       -H "X-Agent-ID: ${AGENT_ID}" \
       "${MCP_URL}/api/config/resolved?agentId=${AGENT_ID}&includeSecrets=true" \
       > /tmp/swarm_config.json 2>/dev/null; then

        CONFIG_COUNT=$(jq '.configs | length' /tmp/swarm_config.json 2>/dev/null || echo "0")
        if [ "$CONFIG_COUNT" -gt 0 ]; then
            echo "Found $CONFIG_COUNT config entries, exporting as env vars..."
            jq -r '.configs[] | "\(.key)=" + (.value | @sh)' /tmp/swarm_config.json > /tmp/swarm_config.env 2>/dev/null || true
            if [ -f /tmp/swarm_config.env ]; then
                set -a
                . /tmp/swarm_config.env
                set +a
                rm -f /tmp/swarm_config.env
            fi
        fi
        rm -f /tmp/swarm_config.json
    else
        echo "Warning: Could not fetch swarm config (API may not be ready)"
    fi
fi
# ---- End swarm config fetch ----

# Create .mcp.json in /workspace (project-level config)
echo "Creating MCP config in /workspace..."
if [ -n "$AGENT_ID" ]; then
    cat > /workspace/.mcp.json << EOF
{
  "mcpServers": {
    "agent-swarm": {
      "type": "http",
      "url": "${MCP_URL}/mcp",
      "headers": {
        "Authorization": "Bearer ${API_KEY}",
        "X-Agent-ID": "${AGENT_ID}"
      }
    }
  }
}
EOF
else
    cat > /workspace/.mcp.json << EOF
{
  "mcpServers": {
    "agent-swarm": {
      "type": "http",
      "url": "${MCP_URL}/mcp",
      "headers": {
        "Authorization": "Bearer ${API_KEY}"
      }
    }
  }
}
EOF
fi

# Configure GitHub authentication if token is provided
echo ""
echo "=== GitHub Authentication ==="
if [ -n "$GITHUB_TOKEN" ]; then
    echo "Configuring GitHub authentication..."

    # gh CLI will automatically use GITHUB_TOKEN env var for API calls
    # Just need to configure git to use gh as credential helper
    gh auth setup-git

    # Set git user config for commits (use env vars or defaults)
    GIT_EMAIL="${GITHUB_EMAIL:-worker-agent@desplega.ai}"
    GIT_NAME="${GITHUB_NAME:-Worker Agent}"
    git config --global user.email "$GIT_EMAIL"
    git config --global user.name "$GIT_NAME"

    echo "GitHub authentication configured successfully"
    echo "Git user: $GIT_NAME <$GIT_EMAIL>"
else
    echo "WARNING: GITHUB_TOKEN not set - git push operations will fail"
fi
echo "=============================="

# Install the desplega-ai marketplace
echo ""
echo "=== Marketplace Installation ==="

if command -v claude >/dev/null 2>&1; then
    echo "Installing desplega-ai/ai-toolbox marketplace..."
    claude plugin marketplace add desplega-ai/ai-toolbox || echo "Toolbox marketplace add failed, continuing..."

    echo "Installing plugins from desplega-ai-toolbox..."
    claude plugin install desplega@desplega-ai-toolbox --scope user || echo "Plugin install failed, continuing..."
    claude plugin install agent-swarm@desplega-ai-toolbox --scope user || echo "Plugin install failed, continuing..."
    claude plugin install wts@desplega-ai-toolbox --scope user || echo "Plugin install failed, continuing..."

    echo "Installing desplega-ai/qa-use marketplace..."
    claude plugin marketplace add desplega-ai/qa-use || echo "qa-use marketplace add failed, continuing..."

    echo "Installing plugins from desplega.ai..."
    claude plugin install qa-use@desplega.ai --scope user || echo "Plugin install failed, continuing..."

    echo "Marketplace installation completed"
else
    echo "WARNING: claude CLI not found, skipping marketplace installation"
fi
echo "==============================="

# Configure and install ai-tracker for tracking AI vs human code changes
echo ""
echo "=== AI Tracker Setup ==="
if command -v ai-tracker >/dev/null 2>&1; then
    # Create shared tracking directory
    TRACKING_DIR="/workspace/shared/tracking"
    mkdir -p "$TRACKING_DIR"

    # Set per-agent database path
    if [ -n "$AGENT_ID" ]; then
        export AI_TRACKER_DB_PATH="${TRACKING_DIR}/${AGENT_ID}.db"
        echo "AI Tracker DB Path: $AI_TRACKER_DB_PATH"
    else
        export AI_TRACKER_DB_PATH="${TRACKING_DIR}/default.db"
        echo "AI Tracker DB Path: $AI_TRACKER_DB_PATH (default, AGENT_ID not set)"
    fi

    # Persist AI_TRACKER_DB_PATH to .bashrc for git hooks and new shell sessions
    # Git hooks spawn fresh shells that don't inherit the exported env var
    if ! grep -q "AI_TRACKER_DB_PATH" ~/.bashrc 2>/dev/null; then
        echo "export AI_TRACKER_DB_PATH=\"${AI_TRACKER_DB_PATH}\"" >> ~/.bashrc
    fi

    # Install ai-tracker hooks (Claude Code PostToolUse hook + git post-commit hook)
    echo "Installing ai-tracker hooks..."
    ai-tracker install || echo "AI Tracker install failed, continuing..."

    echo "AI Tracker setup completed"
else
    echo "WARNING: ai-tracker not found, skipping AI tracking setup"
fi
echo "==============================="


# Find existing startup script in /workspace (start-up.sh, .bash, .js, .ts, .bun, or bare)
find_startup_script() {
    for pattern in start-up.sh start-up.bash start-up.js start-up.ts start-up.bun start-up; do
        if [ -f "/workspace/${pattern}" ]; then
            echo "/workspace/${pattern}"
            return 0
        fi
    done
    return 1
}


# ---- Fetch and compose setup scripts from API ----
if [ -n "$AGENT_ID" ]; then
    echo ""
    echo "=== Setup Script Fetch ==="
    echo "Fetching setup scripts from API..."
    if curl -s -f -H "Authorization: Bearer ${API_KEY}" \
       -H "X-Agent-ID: ${AGENT_ID}" \
       "${MCP_URL}/api/agents/${AGENT_ID}/setup-script" \
       > /tmp/setup_scripts.json 2>/dev/null; then

        GLOBAL_SCRIPT=$(jq -r '.globalSetupScript // empty' /tmp/setup_scripts.json 2>/dev/null)
        AGENT_SCRIPT=$(jq -r '.setupScript // empty' /tmp/setup_scripts.json 2>/dev/null)

        if [ -n "$GLOBAL_SCRIPT" ] || [ -n "$AGENT_SCRIPT" ]; then
            EXISTING_STARTUP=$(find_startup_script) || true

            if [ -n "$EXISTING_STARTUP" ]; then
                # Prepend to existing file (preserve operator content)
                echo "Prepending DB setup script to existing ${EXISTING_STARTUP}..."
                TEMP_FILE=$(mktemp)
                echo "#!/bin/bash" > "$TEMP_FILE"
                # Global script goes outside markers (not synced back to agent DB)
                if [ -n "$GLOBAL_SCRIPT" ]; then
                    echo "# --- Global setup script ---" >> "$TEMP_FILE"
                    echo "$GLOBAL_SCRIPT" >> "$TEMP_FILE"
                    echo "" >> "$TEMP_FILE"
                fi
                # Agent script goes between markers (synced back to DB by hooks)
                if [ -n "$AGENT_SCRIPT" ]; then
                    echo "# === Agent-managed setup (from DB) ===" >> "$TEMP_FILE"
                    echo "$AGENT_SCRIPT" >> "$TEMP_FILE"
                    echo "# === End agent-managed setup ===" >> "$TEMP_FILE"
                fi
                echo "" >> "$TEMP_FILE"
                # Strip shebang, global section, and existing marker sections from original
                sed '1{/^#!/d;}' "$EXISTING_STARTUP" \
                    | sed '/^# --- Global setup script ---$/,/^$/d' \
                    | sed '/^# === Agent-managed setup (from DB) ===$/,/^# === End agent-managed setup ===$/d' \
                    >> "$TEMP_FILE"
                mv "$TEMP_FILE" "$EXISTING_STARTUP"
                chmod +x "$EXISTING_STARTUP"
            else
                # Create new start-up.sh
                echo "Creating /workspace/start-up.sh from DB setup script..."
                echo "#!/bin/bash" > /workspace/start-up.sh
                if [ -n "$GLOBAL_SCRIPT" ]; then
                    echo "# --- Global setup script ---" >> /workspace/start-up.sh
                    echo "$GLOBAL_SCRIPT" >> /workspace/start-up.sh
                    echo "" >> /workspace/start-up.sh
                fi
                if [ -n "$AGENT_SCRIPT" ]; then
                    echo "# === Agent-managed setup (from DB) ===" >> /workspace/start-up.sh
                    echo "$AGENT_SCRIPT" >> /workspace/start-up.sh
                    echo "# === End agent-managed setup ===" >> /workspace/start-up.sh
                fi
                chmod +x /workspace/start-up.sh
            fi
            echo "Setup scripts composed (global: $([ -n "$GLOBAL_SCRIPT" ] && echo "yes" || echo "no"), agent: $([ -n "$AGENT_SCRIPT" ] && echo "yes" || echo "no"))"
        else
            echo "No setup scripts configured"
        fi
        rm -f /tmp/setup_scripts.json
    else
        echo "Warning: Could not fetch setup scripts (API may not be ready)"
    fi
    echo "==============================="
fi
# ---- End setup script fetch ----


# Execute startup script if found
STARTUP_SCRIPT_STRICT="${STARTUP_SCRIPT_STRICT:-true}"
echo ""
echo "=== Startup Script Detection (${ROLE}) ==="

# Find startup script matching /workspace/start-up.* pattern
STARTUP_SCRIPT=$(find_startup_script) || true

if [ -n "$STARTUP_SCRIPT" ]; then
    echo "Found startup script: $STARTUP_SCRIPT"

    # Check if file is executable
    if [ ! -x "$STARTUP_SCRIPT" ]; then
        echo "Script is not executable, checking for shebang..."
    fi

    # Read first line to check for shebang
    FIRST_LINE=$(head -n 1 "$STARTUP_SCRIPT")

    if [[ "$FIRST_LINE" =~ ^#! ]]; then
        # Has shebang - extract interpreter
        INTERPRETER="${FIRST_LINE#\#!}"
        # Trim whitespace
        INTERPRETER=$(echo "$INTERPRETER" | xargs)
        echo "Detected shebang interpreter: $INTERPRETER"

        # Check if it's an env-based shebang (#!/usr/bin/env bash)
        if [[ "$INTERPRETER" =~ ^/usr/bin/env ]]; then
            ACTUAL_INTERPRETER=$(echo "$INTERPRETER" | awk '{print $2}')
            echo "Using env interpreter: $ACTUAL_INTERPRETER"
            INTERPRETER="$ACTUAL_INTERPRETER"
        fi

        echo "Executing startup script with interpreter: $INTERPRETER"
        # Always use the interpreter explicitly to avoid permission issues
        # Use || true to prevent set -e from exiting before we can handle the error
        $INTERPRETER "$STARTUP_SCRIPT" || EXIT_CODE=$?
        EXIT_CODE=${EXIT_CODE:-0}
    else
        # No shebang, try to infer from extension
        EXTENSION="${STARTUP_SCRIPT##*.}"
        echo "No shebang found, inferring from extension: .$EXTENSION"

        case "$EXTENSION" in
            sh|bash)
                echo "Executing with bash..."
                bash "$STARTUP_SCRIPT" || EXIT_CODE=$?
                ;;
            js)
                echo "Executing with node..."
                node "$STARTUP_SCRIPT" || EXIT_CODE=$?
                ;;
            ts)
                echo "Executing with bun (TypeScript)..."
                bun run "$STARTUP_SCRIPT" || EXIT_CODE=$?
                ;;
            bun)
                echo "Executing with bun..."
                bun run "$STARTUP_SCRIPT" || EXIT_CODE=$?
                ;;
            *)
                # Try to execute directly if executable
                if [ -x "$STARTUP_SCRIPT" ]; then
                    echo "Executing directly (executable bit set)..."
                    "$STARTUP_SCRIPT" || EXIT_CODE=$?
                else
                    echo "WARNING: Unknown extension and not executable, trying bash..."
                    bash "$STARTUP_SCRIPT" || EXIT_CODE=$?
                fi
                ;;
        esac
        EXIT_CODE=${EXIT_CODE:-0}
    fi

    # Handle exit code
    if [ $EXIT_CODE -ne 0 ]; then
        echo ""
        echo "ERROR: Startup script failed with exit code $EXIT_CODE"

        if [ "$STARTUP_SCRIPT_STRICT" = "true" ]; then
            echo "STARTUP_SCRIPT_STRICT=true - Exiting..."
            exit $EXIT_CODE
        else
            echo "STARTUP_SCRIPT_STRICT=false - Continuing despite error..."
        fi
    else
        echo "Startup script completed successfully"
    fi
else
    echo "No startup script found (looked for /workspace/start-up.*)"
    echo "Skipping startup script execution"
fi

echo ""
echo "=== Workspace Initialization ==="

# Configure wts for agent use (no tmux, no auto-Claude)
echo "Configuring wts for agent mode..."
mkdir -p /home/worker/.wts
cat > /home/worker/.wts/config.json << EOF
{
  "defaults": {
    "autoTmux": false,
    "autoClaude": false
  }
}
EOF

PERSONAL_DIR="/workspace/personal"
mkdir -p "$PERSONAL_DIR"

if [ ! -f "$PERSONAL_DIR/todos.md" ]; then
    echo "Creating personal todos.md..."
    cat > "$PERSONAL_DIR/todos.md" << EOF
# My TODOs

## Current
- [ ] <task here>
EOF
else
    echo "Personal todo.md already exists, skipping creation"
fi

SHARED_DIR="/workspace/shared/thoughts"

# Create shared thoughts directories
if [ -n "$AGENT_ID" ]; then
    AGENT_THOUGHTS_DIR="$SHARED_DIR/$AGENT_ID"
    echo "Creating shared thoughts directories for agent ID $AGENT_ID..."
    mkdir -p "$AGENT_THOUGHTS_DIR/plans"
    mkdir -p "$AGENT_THOUGHTS_DIR/research"
fi

# shared always
echo "Creating shared thoughts directories..."
mkdir -p "$SHARED_DIR/shared/plans"
mkdir -p "$SHARED_DIR/shared/research"

# Memory directories (auto-indexed by PostToolUse hook)
echo "Creating memory directories..."
mkdir -p "$PERSONAL_DIR/memory"
mkdir -p "/workspace/shared/memory"

echo "==============================="
echo ""

# Run the agent using compiled binary
echo "Starting $ROLE..."
exec /usr/local/bin/agent-swarm "$ROLE" "$@"
